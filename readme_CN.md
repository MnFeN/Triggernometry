本文档是 Triggernometry v1.1.7.3 版本后我所修改部分的中文版总结。

[查看主仓库浏览 Triggernometry 文档](https://github.com/paissaheavyindustries/Triggernometry)


# 新增内容

## 数学解析器 (MathParser)
数学解析器的大部分核心内容已经被重写：
### 负号解析：
已修复负号的解析逻辑中的多个错误：
- 原始代码只检查前一个字符是否是数字来确定 `+`/`-` 是符号还是操作符。这个疏忽导致了像 `func(1, -1)` 或 `1 - -1` 这样的含空格的表达式解析错误。
  - 相关：[#87](https://github.com/paissaheavyindustries/Triggernometry/issues/87)  
- 在 `BasicArithmeticalExpression()` 函数中，当应用负号时，只处理了正值，忽略了非正值。这导致像 `-(-1)` 这样的表达式被错误解析为 `-1`。
  - 相关：[Discord](https://discord.com/channels/374517624228544512/1114692015163191316)  
- 原始代码给了负号一个隐藏的优先级，导致计算顺序错误，比如 `-2^2 = 4`（在大多数现代语言中答案应为 -4）。
- 原始代码未能识别函数前的负号，如 `-func(args)` ，导致 `0 = -sin(0)` 这样的表达式中，代码会尝试在 `=` 和 `sin(0)` 之间做减法而出错。
  - 相关：[Discord](https://discord.com/channels/374517624228544512/1114692015163191316)

这些错误已被修复，处理 +/- 符号的全部逻辑已重构并简化。旧版词法分析器和解析器都使用特殊逻辑处理 `+`/`-`；现在，词法分析器仅将其视为正常运算符，而在解析器中用一个简单逻辑即可处理正负号。

### 词法分析逻辑 (Lexer)
- 词法分析器已简化，只专注于当前字符是否属于操作符字符，并将操作符与非操作符拆分。
- 如果解析器无法解析基本表达式，它会抛出一个错误，详细说明哪个操作符在哪个表达式中无法被解析。
- 旧版词法分析器尝试在像 `3abs(0)` 这样的表达式之间添加 `*`，但这种方法逻辑和原理上都不正确：
  - 若不花费额外时间扫描整个函数列表匹配函数名，则不可能区分 `3abs(0)` 中的 `3ab` 和十六进制数字 `3ab`；
  - 代码中当 `a` 前面有 `3` 时，`3` 会作为 token 的开始，并没有机会检查 `a` 前是什么。
- 为了不花费额外时间解析函数名，并未支持此类隐式乘号，数字和函数/常量之间依然需要显式的 `*`。

### 操作符
- 旧版解析器只支持单字符二元左结合运算符。核心逻辑重写后，解析器现在额外支持双字符、一/三元、右结合操作符。
- 已添加以下操作符：
  - `&&` `||` `^^` `!`：逻辑运算 与/或/异或/非。  
  - `%%` `//`：模和整除。注意模是 mod 而非 remainder（与除数同号），整除结果永远向下取整。
  - `√`：根号（一元运算符）
  - `>=` `<=` `==` `!=`：作为别名
  - `&` `|` `<<` `>>`：位运算（如：可以方便地使用单个变量存储并解析多个实体在随机位置出现的状态）
  - `? :`：三元运算符

### 精度误差容差
- 容差级别已从 `double.Epsilon` 更改为常数（设为 `δ` =  `1E-9`），以便 Triggernometry 使用。
- 这条规则只适用于涉及（显式或隐式）比较的函数和操作符，如 `=` `>` `>=` `sign` `truncate` 等。
- 在比较过程中，范围在 `x ± δ` 内的值均会被视为 `x`。

### 别名
- 在原始代码中，存在一个别名列表（例如 `atan2` => `arctan2`），但未被使用。
- 由于与 Triggernometry 的需求无关，已删除这些代码行，并直接将别名加入到函数列表中。

### 空格
- 现在解析表达式前会删除全部空格以简化逻辑。这意味着表达式中的任意空格将不会影响结果。
- 副作用：数字字符串函数现在不能在其参数中包含有意义的空格（不过此前并没有此类函数）。

## 参数
- 原始的 `SplitArgument` 函数在遇到不匹配的引号或连续的逗号时生成了错误的 `args` 列表。此外它并不支持换行符。
- 修改后的代码现在使用正则表达式来精确提取位于字符串开始、结束和逗号之间的所有参数。
- 单/双引号外的表达式会被剔除首尾空白；单独的空字符串或空格会返回空列表。
- 例如，(1,2,  3  ,"  4  ",   "5"  , "'", ', ', ) 现在转换为参数列表：
  - `1` `2` `3` `  4  ` `5` `'` `, ` `(空)`.
- 根据解析表达式时的展开逻辑，参数无法包含 `)` `{` `}`。所以添加了以下转义规则：
  + `{` 应该用全角 `｛` 或 `__LB__` 转义； （注：全角字符即中文输入法下的字符）
  + `}` 应该用全角 `｝` 或 `__RB__` 转义；
  + `(` **可以**用全角 `（` 或 `__LP__` 转义；
  + `)` 应该用全角 `）` 或 `__RP__` 转义；
  + `｛` `｝` 应该用 `__FLB__` `__FRB__` 转义；
  + `（` `）` 应该用 `__FLP__` `__FRP__` 转义；

## 索引和切片
### 负索引
- 索引现在支持负值，从后向前计数。
- 涵盖以下内容：`substring`；`lvar`；`tvar`；`tvarrl`；`tvarcl`；以及列表/表格操作中的 `index`/`row`/`column` 索引文本框。
- 之前的索引关键字 "last" 现在重定向到 -1。
- 例如，`${tvar:myTable[2][-3]}` 返回 `2nd` 列和 `-3rd` 行的值。
### 切片 (slice)
- 一个像 `start:end:step` 的切片表达式可以表示从 `start` 开始，每次增加 `step`，并在 `end` 之前结束的一系列索引。
- 此功能与 Python 的切片机制非常相似。
- 所有三个整数都可以省略：`a:b:c` `a:b:` `a::c` `:b:c` `a::` `:b:` `::c` `::` `a:b` `a:` `:b` `:` 
- 索引支持负值；字符串从 0 开始计数，列表/表格从 1 开始计数，与之前的 Triggernometry 功能保持一致。
- **切片**（和索引）可以合并成一个 **切片** 表达式 (slices)，例如：`:5, 7, 8:13:2, 16:` 表示 `(0), 1, 2, 3, 4, 7, 8, 10, 12, 16, 17, (...直到结束)`。
- 切片表达式广泛用于新特性中，在字符串表达式即可实现“伪”高维的列表/表格操作，且无需循环即可简化表达式/动作。
- 注意：“slices” 在函数和方法中被认为是单一参数。如果它包含逗号，需要将切片表达式包含在 `""` 或 `''` 中。

## 自动填充表单 （Autofill，即输入表达式时显示的预选单）
- 修复了一个表单不隐藏的错误，如输入 `tvar:` 后仍然显示 `tvarrl`；
- 添加了更多类型的自动填充：列表/表格/字典的属性；当前临时/永久变量、悬浮窗、常量名；当前触发器中的正则捕获组名；字典键和表格行列查找模式下的表头；
- 代码现在搜索前面的未关闭 `{` 以提供更智能的自动填充建议；(例如，`${lvar:xxx${var:yyy}${index}.` 会匹配到最开始的大括号，显示列表属性)；
- 自动填充表单现在准确出现在其匹配的字符串下方；
- 修复了多行模式下的错误：用 enter 键选择自动填充的同时会额外插入一个换行；
- 增加了自动完成框的高度 (5 → 10) 和宽度 ( → 所有匹配文本的最大长度)；
- 添加了一个去抖计时器：在文本框中的文本更改后开始 200 ms 倒计时，随后触发自动填充逻辑。此倒计时内再次更改文字会重置计时器，以在快速输入或按住删除时避免延迟。
  
## 字典变量  
- 补全了未启用的 VariableDictionary 类，并添加了相应的表达式、方法、动作、变量浏览器。  
- 详见下文。

## 表达式和函数  
### 特殊变量:  
|表达式|描述|  
|:---|:---|  
|`_ETprecise`|提供垂直日的确切分钟。<br />是 `_ffxivtime` (`_ET`) 的更准确版本。|  
|`_idx`|动态表达式。代表当前索引。|  
|`_col`|动态表达式。代表当前列索引。|  
|`_row`|动态表达式。代表当前行索引。|  
|`_col[i]`|动态表达式。代表当前列中行索引 `i` 的值。|  
|`_row[i]`|动态表达式。代表当前行中列索引 `i` 的值。|  
|`_this`|动态表达式。代表当前列表或表格单元的值。|  
|`_key` <br />`_val`|动态表达式。代表当前的键/值。|  
|`_clipboard`|系统剪贴板中当前复制的文本。|  

关于动态表达式的详细信息，请参阅操作部分。

### 数值常量:  
|表达式|描述|  
|:---|:---|  
|`semitone`|`2^(1/12)`。<br />两个相邻半音之间的频率比率。|  
|`cent`|`2^(1/1200)`。<br />两个相邻音分之间的频率比率。|  
|`ETmin2sec`|`35/12`。<br />艾欧泽亚 1 分钟和现实 1 秒之间的比率。|  

### 数学函数:  
|表达式|描述|示例|  
|:---|:---|:---|  
|`distance()`|现在支持 2 组 _`n`_ 维坐标。<br />当 _`n`_ = `2` 时，与之前的版本行为一致。|`distance(0,0,0, 3,4,12)` = `13`|  
|`projectdistance()`<br />`projectheight()`|射影长度及射影高度，如图。![proj](https://github.com/MnFeN/Triggernometry/assets/85232361/87d24efc-0d67-4d26-946a-81e91d3ba4c2)<br />在涉及直线/射线型 AoE 的计算时很有用。|`projd(0,0, pi/6, -2,0)` = `-1`<br />`projh(0,0, pi/6, -2,0)` = `1.732...`|  
|`angle(x1, y1, x2, y2)`|= `atan2(x2-x1, y2-y1)`|`angle(100, 100, 120, 100)` = `1.57...`|  
|`relangle(θ1, θ2)`|将 `θ1` 作为相对北，返回 `θ2` 的方向，规范至 `[-π, π)` 区间。|`relangle(0, -pi/2)` = `1.57...`|  
|`roundir(θ, ±n, digits = 0)`<br />`roundvec(x, y, ±n, digits = 0)`|将给定方向（`roundir` 以弧度表示；`roundvec` 函数中以向量的分量 dx, dy 表示）与一个 `\|n\|` 等分的圆中的方向匹配，然后返回该方向的索引。<br />`n` 的符号表示两种划分模式：正北本身是等分点，或正点位于两个等分点的中点，如下所示。<br />`digits` 指定舍入的小数位数；负值代表不舍入。<br />![image](https://github.com/paissaheavyindustries/Triggernometry/assets/85232361/b7ab1f13-c5ba-4609-b588-b066d5d9d4e1)<br />例如，用于计算具有多个潜在生成点的实体的方向。可以与 `func:pick(index)` 结合使用，从弧度或坐标输出任何方向为字符串，无需复杂的 `arctan2` 和 `mod` 计算。|`roundir(-1.57,4)`<br /> = `1` (西)<br />`roundvec(8,-6,-4)`<br /> = `3` (东北)|  

### 数学函数（字符串）：
|表达式|描述|示例|
|:---|:---|:---|
|`parsedmg(hex)`|将 `0x15`/`0x16` ACT 日志行中的 16 进制伤害/治疗字符串转换为相应的十进制值。<br />规则：用 `0` 从左侧填充16进制字符串到8位为 `XXXXYYZZ`，然后将 `ZZXXXX` 转换为十进制。|`parsedmg(A00000)` = `160`|
|`freq(note, semitones = 0)`|返回指定音符（使用科学音高表示法，变音符用 `#`、`b`、`x` 表示）加上半音偏移后的频率（Hz）。|`freq(A4)` <br />= `freq(G#4, 1)` <br />= `freq(Bb4, -1)` <br />= `freq(A5, -12)` <br />= `440`|
|`nextETms(XX:XX)` `nextETms(ETminutes)`|提供直到下一次指定的艾欧泽亚时间的现实剩余时间（ms）。|当前 ET 为 `1:00`：<br />`nextETms(2:00)`<br />= `nextETms(02:00.00)`<br />=`nextETms(120)`<br />= `175000` (2 min 55 s)|

### 字符串函数：
|表达式|描述|示例|
|:---|:---|:---|
|`parsedmg`|与数学函数相同。不接受任何参数。|`func:parsedmg:A00000`<br />= `160`|
|`slice(slices = ":")`|接受一个切片表达式作为参数，返回字符串的指定切片。|`func:slice(-3):01234` = `2`<br />`func:slice(1:4):01234` = `123`<br />`func:slice(::-1):01234` = `43210`<br />`func:slice("1,3:"):01234` = `134`|
|`pick(index, separator = ",")`|按指定的分隔符分隔给定字符串。<br />根据索引返回子字符串，从 0 开始。<br />支持负索引。|`func:pick(3):north,west,south,east`<br /> = `east`<br />`func:pick(-1,", "):1, 22, 3, 44, 5`<br /> = `5`|
|`contain(str)`<br />`startwith(str)`<br />`endwith(str)`<br />`equal(str)`|返回 `1` 或 `0`。|`func:contain(23):1234` = `1` <br />`func:endwith(23):1234` = `0`<br />`func:equal(23):1234` = `0`|
|`ifcontain(str, t, f)`<br />`ifstartwith(str, t, f)`<br />`ifendwith(str, t, f)`<br />`ifequal(str, t, f)`|与 `if()` 类似。|`func:ifcontain(23, a, b):1234` = `a` <br />`func:ifendwith(23, a, b):1234` = `b`<br />`func:ifequal(23, a, b):1234` = `b`|
|`indicesof(str, joiner = ",", slices = ":")`|在字符串的指定部分搜索所有索引，然后以 joiner 连接。|`func:indicesof(a):abcbabcba` = `0,4,8`<br />`func:indicesof(a, "-", ::-1):abcbabcba` = `8-4-0`|
|`match(str):regex`|返回 `1` 或 `0`。<br />注意：正则表达式不应包含 `{` `}`。<br />`{` 应使用全宽 `｛` 或 `__LB__` 转义；<br />`}` 应使用全宽 `｝` 或 `__RB__` 转义；<br />`｛` `｝` 应使用 `__FLB__` `__FRB__` 转义。<br />下面两个函数同样适用这些正则规则。|`func:match(404D):404[B-D]` = `1`<br />`func:match(4000A3BF):4.｛7｝` = `1`|
|`capture(str, group):regex`|返回捕获的字符串 `$groupindex` 或 `${groupname}`。如果 `groupindex` = `0`，则返回整个匹配的字符串。<br />如果找不到 `groupname` 或 `groupindex` 超出范围，则返回一个空字符串。<br />遵循前述正则规则。|`func:capture(Player NameGilgamesh, server):.+ .+(?<server>[A-Z].+)`<br />= `Gilgamesh`|
|`ifmatch(str, t, f):regex`|与 `if()` 类似。|`func:match(404D, a, b):404[B-D]` = `a`|
|`replace(oldStr, newStr = "", isLooped = 0)`|在指定字符串中用新字符串替换旧字符串。可以循环替换。|`func:replace(" "):1 2 3`<br />= `123`<br />`func:replace(aa,a):aaaaaa`<br />= `aaa`<br />`func:replace(aa,a,1):aaaaaa`<br />= `a`|
|`repeat(times, joiner = "")`|重复指定次数的字符串，可以添加连接符。|`func:repeat(3):a` = `aaa`<br />`func:repeat(3, +):1` = `1+1+1`|
|`padleft`<br />`padright`<br />`trim`<br />`trimleft`<br />`trimright`  |这些旧版本中只支持字符码的函数，现在可以接受字符本身或其字符码。<br />`0`-`9` 被解释为字符而不是字符码，因为 ASCII 0-9 控制字符几乎不会使用到。<br />
